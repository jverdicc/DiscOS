// Copyright (c) 2026 Joseph Verdicchio and DiscOS  Contributors
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package evidenceos.v1;

// EvidenceOS is a verification kernel service.
//
// This is a reference IPC surface for a Rust kernel implementation.
// Production deployments should harden and possibly split "simulation" endpoints
// into a separate build/profile.

service EvidenceOS {
  rpc Health(HealthRequest) returns (HealthResponse);

  // Create a new session (per identity / per workflow).
  rpc CreateSession(CreateSessionRequest) returns (CreateSessionResponse);

  // Simulation-only: create a synthetic holdout inside the kernel.
  rpc InitHoldout(InitHoldoutRequest) returns (InitHoldoutResponse);

  // Accuracy oracle for label-holdout datasets.
  rpc OracleAccuracy(OracleAccuracyRequest) returns (OracleReply);

  // Safety oracle for scalar-boundary datasets.
  rpc OracleBoundarySafety(OracleBoundarySafetyRequest) returns (OracleReply);

  // Accuracy oracle for scalar-boundary datasets.
  rpc OracleBoundaryAccuracy(OracleBoundaryAccuracyRequest) returns (OracleReply);

  // Final evaluation + certification attempt for label-holdout datasets.
  rpc EvaluateAndCertify(EvaluateAndCertifyRequest) returns (EvaluateAndCertifyResponse);

  // Read current ledger snapshot.
  rpc GetLedger(GetLedgerRequest) returns (LedgerSnapshot);

  // Read ETL (append-only log) root.
  rpc GetEtlRoot(GetEtlRootRequest) returns (GetEtlRootResponse);

  // Claim lifecycle APIs used by DiscOS.
  rpc CreateClaim(CreateClaimRequest) returns (CreateClaimResponse);
  rpc CommitArtifacts(CommitArtifactsRequest) returns (CommitArtifactsResponse);
  rpc Seal(SealRequest) returns (SealResponse);
  rpc Execute(ExecuteRequest) returns (ExecuteResponse);
  rpc FetchCapsule(FetchCapsuleRequest) returns (FetchCapsuleResponse);
  rpc VerifyEtlProofs(VerifyEtlProofsRequest) returns (VerifyEtlProofsResponse);
  rpc WatchRevocations(WatchRevocationsRequest) returns (stream RevocationEvent);
}

message HealthRequest {}
message HealthResponse {
  string status = 1; // "SERVING" or "NOT_SERVING"
}

message CreateSessionRequest {
  // Risk target for certification.
  double alpha = 1;

  // Logical epoch size for deterministic logical clock (DLC).
  uint64 epoch_size = 2;

  // Hysteresis threshold (delta_sigma) for oracle output stalling.
  double hysteresis_delta = 3;

  // Number of oracle buckets for accuracy-style oracles.
  uint32 oracle_buckets = 4;

  // Joint information budget (bits). If 0, treat as "infinite" for baseline comparisons.
  uint64 joint_bits_budget = 5;

  // Fixed alternative hypothesis probability for the built-in binomial LR e-value.
  // (p1 > 0.5). If 0, defaults to 0.60.
  double binom_p1 = 6;
}

message CreateSessionResponse {
  string session_id = 1;
}

enum HoldoutKind {
  HOLDOUT_KIND_UNSPECIFIED = 0;

  // A private vector of binary labels; accuracy is computed from a submitted prediction vector.
  HOLDOUT_KIND_LABELS = 1;

  // A private scalar boundary b in [0,1]; used for cross-oracle probing simulations.
  HOLDOUT_KIND_SCALAR_BOUNDARY = 2;
}

message InitHoldoutRequest {
  string session_id = 1;
  HoldoutKind kind = 2;

  // Deterministic seed (simulation only).
  uint64 seed = 3;

  // For LABELS: number of labels. For SCALAR_BOUNDARY: ignored.
  uint32 size = 4;
}

message InitHoldoutResponse {
  string holdout_id = 1;
}

message OracleAccuracyRequest {
  string session_id = 1;
  string holdout_id = 2;

  // Packed bits: each byte is 0 or 1.
  bytes predictions = 3;
}

message OracleBoundarySafetyRequest {
  string session_id = 1;
  string holdout_id = 2;
  double x = 3;
}

message OracleBoundaryAccuracyRequest {
  string session_id = 1;
  string holdout_id = 2;
  double x = 3;
}

message OracleReply {
  // Canonicalized bucket index in [0, num_buckets-1].
  // For 1-bit oracles, num_buckets==2 and bucket is 0/1.
  uint32 bucket = 1;
  uint32 num_buckets = 2;

  // Deterministic logical clock epoch counter.
  uint64 logical_epoch = 3;

  // Ledger debug: total k bits charged so far (joint pool).
  double k_bits_total = 4;

  // Ledger debug: current certification barrier (2^k / alpha).
  double barrier = 5;

  // If true, kernel has frozen the session due to budget exhaustion or safety trip.
  bool frozen = 6;
}

message EvaluateAndCertifyRequest {
  string session_id = 1;
  string holdout_id = 2;
  bytes predictions = 3;

  // Claim metadata (opaque to kernel; stored in capsule).
  string claim_name = 4;
}

message EvaluateAndCertifyResponse {
  bool certified = 1;
  double e_value = 2;
  double wealth = 3;
  double barrier = 4;
  double k_bits_total = 5;

  // If certified, the claim capsule hash (sha256 hex).
  string capsule_hash = 6;

  // If certified, the ETL leaf index.
  uint64 etl_index = 7;
}

message GetLedgerRequest {
  string session_id = 1;
}

message LedgerEvent {
  string kind = 1;
  double bits = 2;
  string json_meta = 3;
}

message LedgerSnapshot {
  double alpha = 1;
  double alpha_prime = 2;
  double k_bits_total = 3;
  double barrier = 4;
  double wealth = 5;
  repeated LedgerEvent events = 6;
}

message GetEtlRootRequest {}
message GetEtlRootResponse {
  string root_hash_hex = 1;
  uint64 tree_size = 2;
}

message ClaimMetadata {
  string lane = 1;
  uint32 alpha_micros = 2;
  string epoch_config_ref = 3;
  string output_schema_id = 4;
}

message TopicSignals {
  bytes semantic_hash = 1;
  bytes phys_hir_signature_hash = 2;
  bytes dependency_merkle_root = 3;
}

message CreateClaimRequest {
  string claim_id = 1;
  ClaimMetadata metadata = 2;
  TopicSignals signals = 3;
}

message CreateClaimResponse {
  string claim_id = 1;
  bytes topic_id = 2;
}

message ArtifactManifest {
  string name = 1;
  bytes canonical_bytes = 2;
  bytes digest = 3;
}

message CommitArtifactsRequest {
  string claim_id = 1;
  bytes wasm_module = 2;
  bytes wasm_hash = 3;
  repeated ArtifactManifest manifests = 4;
}

message CommitArtifactsResponse {
  bool accepted = 1;
}

message SealRequest {
  string claim_id = 1;
}

message SealResponse {
  bool sealed = 1;
}

message ExecuteRequest {
  string claim_id = 1;
}

message ExecuteResponse {
  bool executed = 1;
  string execution_id = 2;
}

message FetchCapsuleRequest {
  string claim_id = 1;
}

message MerkleInclusionProof {
  bytes leaf_hash = 1;
  uint64 leaf_index = 2;
  uint64 tree_size = 3;
  repeated bytes audit_path = 4;
}

message MerkleConsistencyProof {
  uint64 old_tree_size = 1;
  uint64 new_tree_size = 2;
  repeated bytes path = 3;
}

message FetchCapsuleResponse {
  string claim_id = 1;
  bytes capsule = 2;
  uint64 etl_index = 3;
  uint64 etl_tree_size = 4;
  bytes etl_root_hash = 5;
  bytes sth_signature = 6;
  MerkleInclusionProof inclusion = 7;
  MerkleConsistencyProof consistency = 8;
}

message VerifyEtlProofsRequest {
  bytes root_hash = 1;
  MerkleInclusionProof inclusion = 2;
  MerkleConsistencyProof consistency = 3;
  uint64 trusted_tree_size = 4;
  bytes trusted_root_hash = 5;
}

message VerifyEtlProofsResponse {
  bool inclusion_ok = 1;
  bool consistency_ok = 2;
}

message WatchRevocationsRequest {}

message RevocationEvent {
  string claim_id = 1;
  string reason_code = 2;
  uint64 logical_epoch = 3;
}
